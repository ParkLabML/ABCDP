"""Module containing classes for extracting/constructing features from data"""

__author__ = 'wittawat'

from abc import ABCMeta, abstractmethod
import numpy as np
import scipy.stats as stats
import auxiliary_files.util as util


class FeatureMap(object):
    """Abstract class for a feature map function"""
    __metaclass__ = ABCMeta

    @abstractmethod
    def gen_features(self, X):
        """Generate D features for each point in X.
        - X: nxd data matrix

        Return a n x D numpy array.
        """
        pass

    @abstractmethod
    def num_features(self, X=None):
        """
        Return the number of features that this map will generate for X.
        X is optional.
        """
        pass

    def __call__(self, X):
        return self.gen_features(X)


class MarginalCDFMap(FeatureMap):
    """
    A FeatureMap that returns a new set of variates generated by applying
    the empirical CDF of each variate to its corresponding variate.
    Also called, a copula transform or a probability integral transform.
    """
    def gen_features(self, X):
        """
        Cost O(dn*log(n)) where X in n x d.
        """
        n, d = X.shape
        Z = np.zeros((n, d))
        for j in range(d):
            Z[:, j] = stats.rankdata(X[:, j])/float(n)
        return Z

    def num_features(self, X):
        return X.shape[1]


class RFFKGauss(FeatureMap):
    """
    A FeatureMap to construct random Fourier features for a Gaussian kernel.
    """
    def __init__(self, sigma2, n_features, seed=1):
        """
        n_features: number of random Fourier features. The total number of
            dimensions will be n_features. Internally draw n_features/2
            frequency components. n_features has to be even.
        """
        if sigma2 <= 0:
            raise ValueError('sigma2 is not positive. Was {}'.format(sigma2))
        if not (n_features > 0 and n_features % 2 == 0):
            raise ValueError('n_features has to be even positive integer (just for our convenience). Was {}'.format(n_features))
        self.sigma2 = sigma2
        self.n_features = n_features
        self.seed = seed

    def gen_features(self, X):
        # The following block of code is deterministic given seed.
        # Fourier transform formula from
        # http://mathworld.wolfram.com/FourierTransformGaussian.html
        with util.NumpySeedContext(seed=self.seed):
            n, d = X.shape

            draws = self.n_features//2
            W = np.random.randn(draws, d)/np.sqrt(self.sigma2)
            # n x draws
            XWT = X.dot(W.T)
            Z1 = np.cos(XWT)
            Z2 = np.sin(XWT)
            Z = np.hstack((Z1, Z2))*np.sqrt(2.0/self.n_features)
        return Z

    def num_features(self, X=None):
        return self.n_features


# class NystromFeatureMap(FeatureMap):
#     """
#     A FeatureMap to construct features Z (n x D) such that Z.dot(Z.T) gives
#     a good approximation to the kernel matrix K constructed by using the
#     specified kernel k.

#     Procedure
#     - A subset of D inducing points is given.
#     - Form an n x D kernel matrix K between the input points and the inducing
#       points.
#     - Form a D x D kernel matrix M of the inducing points.
#     - Features = K.dot(M**-0.5) (matrix power)
#     """
#     def __init__(self, k, inducing_points):
#         """
#         k: a Kernel
#         inducing_points: a D x d matrix. D = number of points. d = dimensions.
#             The number of features is D.
#         """
#         self.k = k
#         self.inducing_points = inducing_points
#         # a cache to make it faster
#         M = k.eval(inducing_points, inducing_points)
#         # eigen decompose. Want to raise to the power of -0.5
#         evals, V = np.linalg.eig(M)
#         # Assume M is full rank
#         pow_evals = 1.0/np.sqrt(evals + 1e-6)
#         self._invert_half = V.dot(np.diag(pow_evals)).dot(V.T)

#     def gen_features(self, X):
#         n, d = X.shape
#         if d != self.inducing_points.shape[1]:
#             raise ValueError('dimension of the input does not match that of the inducing points')
#         K = self.k.eval(X, self.inducing_points)
#         Z = K.dot(self._invert_half)
#         return Z

#     def num_features(self, X=None):
#         return self.inducing_points.shape[1]
